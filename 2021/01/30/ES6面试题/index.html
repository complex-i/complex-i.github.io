<!DOCTYPE html><html lang="zh-Hans-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Talking about ES6 | Sibyl</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.3.0"></head><body><header><nav><a href="/">主页</a><a href="/archives/">文章分类</a></nav></header><main><article><div id="post-bg"><div id="post-title"><div id="post-info"><span>date:<time datetime="2021-01-29T17:08:01.000Z" id="date"> 2021-01-30</time></span><br><span>updated:<time datetime="2021-01-29T17:28:39.928Z" id="updated"> 2021-01-30</time></span></div><h1>Talking about ES6</h1><hr></div><div id="post-content"><h2 id="ES5和ES6的区别"><a href="#ES5和ES6的区别" class="headerlink" title="ES5和ES6的区别:"></a>ES5和ES6的区别:</h2><p>ECMAScript5，即ES5，是ECMAScript的第五次修订，于2009年完成标准化ECMAScript6，即ES6，是ECMAScript的第六次修订，于2015年完成，也称ES2015ES6是继ES5之后的一次改进，相对于ES5更加简洁，提高了开发效率ES6新增的一些特性：</p>
<p>1）let声明变量和const声明常量，两个都有块级作用域ES5中是没有块级作用域的，并且var有变量提升，在let中，使用的变量一定要进行声明<br>2）箭头函数ES6中的函数定义不再使用关键字function()，而是利用了()=&gt;来进行定义<br>3）模板字符串模板字符串是增强版的字符串，用反引号（`）标识，可以当作普通字符串使用，也可以用来定义多行字符串<br>4）解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值<br>5）for of循环for…of循环可以遍历数组、Set和Map结构、某些类似数组的对象、对象，以及字符串<br>6）import、export导入导出ES6标准中，Js原生支持模块(module)。将JS代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用<br>7）set数据结构Set数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数<br>8）… 展开运算符可以将数组或对象里面的值展开；还可以将多个值收集为一个变量<br>9）修饰器 @decorator是一个函数，用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数<br>10）class 类的继承ES6中不再像ES5一样使用原型链实现继承，而是引入Class这个概念<br>11）async、await使用 async/await, 搭配promise,可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成<br>12）promisePromise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理、强大<br>13）SymbolSymbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的<br>14）Proxy代理使用代理（Proxy）监听对象的操作，然后可以做一些相应事情</p>
<h2 id="var、let、const之间的区别"><a href="#var、let、const之间的区别" class="headerlink" title="var、let、const之间的区别"></a>var、let、const之间的区别</h2><p>var声明变量可以重复声明，而let不可以重复声明<br>var是不受限于块级的，而let是受限于块级<br>var会与window相映射（会挂一个属性），而let不与window相映射<br>var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错<br>const声明之后必须赋值，否则会报错<br>const定义不可变的量，改变了就会报错<br>const和let一样不会与window相映射、支持块级作用域、在声明的上面访问变量会报错</p>
<h2 id="使用箭头函数应注意什么？"><a href="#使用箭头函数应注意什么？" class="headerlink" title="使用箭头函数应注意什么？"></a>使用箭头函数应注意什么？</h2><p>（1）用了箭头函数，this就不是指向window，而是父级（指向是可变的）<br>（2）不能够使用arguments对象<br>（3）不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误<br>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数</p>
<h2 id="ES6的模板字符串有哪些新特性？并实现一个类模板字符串的功能"><a href="#ES6的模板字符串有哪些新特性？并实现一个类模板字符串的功能" class="headerlink" title="ES6的模板字符串有哪些新特性？并实现一个类模板字符串的功能"></a>ES6的模板字符串有哪些新特性？并实现一个类模板字符串的功能</h2><p>基本的字符串格式化。<br>将表达式嵌入字符串中进行拼接。<br>用${}来界定在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。<br>ES6反引号(``)就能解决类模板字符串的功能</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> name = <span class="hljs-string">&#x27;web&#x27;</span>;<br><span class="hljs-built_in">let</span> age = 10;<br><span class="hljs-built_in">let</span> str = <span class="hljs-string">&#x27;你好，$&#123;name&#125; 已经 $&#123;age&#125;岁了&#x27;</span><br>str = str.replace(/\$\&#123;([^&#125;]*)\&#125;/g,<span class="hljs-function"><span class="hljs-title">function</span></span>()&#123;<br>     <span class="hljs-built_in">return</span> <span class="hljs-built_in">eval</span>(arguments[1]);<br>   &#125;)<br>console.log(str);//你好，web 已经 10岁了<br></code></pre></td></tr></table></figure>
<h2 id="介绍下-Set、Map的区别？"><a href="#介绍下-Set、Map的区别？" class="headerlink" title="介绍下 Set、Map的区别？"></a>介绍下 Set、Map的区别？</h2><p>应用场景Set用于数据重组，Map用于数据储存Set：　<br>（1）成员不能重复<br>（2）只有键值没有键名，类似数组<br>（3）可以遍历，方法有add, delete,has<br>Map:<br>（1）本质上是健值对的集合，类似集合<br>（2）可以遍历，可以跟各种数据格式转换</p>
<h2 id="ECMAScript6-怎么写-class-，为何会出现-class？"><a href="#ECMAScript6-怎么写-class-，为何会出现-class？" class="headerlink" title="ECMAScript6 怎么写 class ，为何会出现 class？"></a>ECMAScript6 怎么写 class ，为何会出现 class？</h2><p>ES6的class可以看作是一个语法糖，它的绝大部分功能ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">//定义类<br>class Point &#123; <br>  constructor(x,y) &#123; <br>      //构造方法<br>       this.x = x; //this关键字代表实例对象<br>       this.y = y; <br>  &#125; <span class="hljs-function"><span class="hljs-title">toString</span></span>() &#123;<br>       <span class="hljs-built_in">return</span> <span class="hljs-string">&#x27;(&#x27;</span> + this.x + <span class="hljs-string">&#x27;,&#x27;</span> + this.y + <span class="hljs-string">&#x27;)&#x27;</span>; <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Promise构造函数是同步执行还是异步执行，那么-then-方法呢？"><a href="#Promise构造函数是同步执行还是异步执行，那么-then-方法呢？" class="headerlink" title="Promise构造函数是同步执行还是异步执行，那么 then 方法呢？"></a>Promise构造函数是同步执行还是异步执行，那么 then 方法呢？</h2><p>promise构造函数是同步执行的，then方法是异步执行的</p>
<h2 id="setTimeout、Promise、Async-Await-的区别"><a href="#setTimeout、Promise、Async-Await-的区别" class="headerlink" title="setTimeout、Promise、Async/Await 的区别"></a>setTimeout、Promise、Async/Await 的区别</h2><p>事件循环中分为宏任务队列和微任务队列<br>其中setTimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行async函数表示函数里面可能会有异步方法，await后面跟一个表达式<br>async方法执行时，遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行</p>
<h2 id="promise有几种状态，什么时候会进入catch？"><a href="#promise有几种状态，什么时候会进入catch？" class="headerlink" title="promise有几种状态，什么时候会进入catch？"></a>promise有几种状态，什么时候会进入catch？</h2><p>三个状态：<br>pending、fulfilled、reject<br>两个过程：<br>padding -&gt; fulfilled、padding -&gt; rejected当pending为rejectd时，会进入catch</p>
<h2 id="下面的输出结果是多少"><a href="#下面的输出结果是多少" class="headerlink" title="下面的输出结果是多少"></a>下面的输出结果是多少</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">const promise = new Promise((resolve, reject) =&gt; &#123;<br>    console.log(1);<br>    resolve();<br>    console.log(2);<br>&#125;)<br><br><br>promise.then(() =&gt; &#123;<br>    console.log(3);<br>&#125;)<br><br><br>console.log(4);<br></code></pre></td></tr></table></figure>
<p>Promise 新建后立即执行，所以会先输出 1，2，而 Promise.then()内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3</p>
<h2 id="使用结构赋值，实现两个变量的值的交换"><a href="#使用结构赋值，实现两个变量的值的交换" class="headerlink" title="使用结构赋值，实现两个变量的值的交换"></a>使用结构赋值，实现两个变量的值的交换</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> a = 1;<span class="hljs-built_in">let</span> b = 2;<br>[a,b] = [b,a];<br></code></pre></td></tr></table></figure>
<h2 id="设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key"><a href="#设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key" class="headerlink" title="设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key"></a>设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> name = Symbol(<span class="hljs-string">&#x27;name&#x27;</span>);<br> <span class="hljs-built_in">let</span> product = &#123;<br>    [name]:<span class="hljs-string">&quot;洗衣机&quot;</span>,    <br>    <span class="hljs-string">&quot;price&quot;</span>:799<br>  &#125;;<br>  Reflect.ownKeys(product);<br></code></pre></td></tr></table></figure>

<h2 id="下面Set结构，打印出的size值是多少"><a href="#下面Set结构，打印出的size值是多少" class="headerlink" title="下面Set结构，打印出的size值是多少"></a>下面Set结构，打印出的size值是多少</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> s = newSet();<br>s.add([1]);s.add([1]);<br>console.log(s.size);<br></code></pre></td></tr></table></figure>
<p>答案：2<br>两个数组[1]并不是同一个值，它们分别定义的数组，在内存中分别对应着不同的存储地址，因此并不是相同的值都能存储到Set结构中，所以size为2</p>
<h2 id="Promise-中reject-和-catch-处理上有什么区别"><a href="#Promise-中reject-和-catch-处理上有什么区别" class="headerlink" title="Promise 中reject 和 catch 处理上有什么区别"></a>Promise 中reject 和 catch 处理上有什么区别</h2><p>reject 是用来抛出异常，catch 是用来处理异常<br>reject 是 Promise 的方法，而 catch 是 Promise 实例的方法<br>reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch<br>网络异常（比如断网），会直接进入catch而不会进入then的第二个回调</p>
<h2 id="使用class-手写一个promise"><a href="#使用class-手写一个promise" class="headerlink" title="使用class 手写一个promise"></a>使用class 手写一个promise</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash">//创建一个Promise的类<br>  class Promise&#123;<br>    constructor(executer)&#123;//构造函数constructor里面是个执行器<br>      this.status = <span class="hljs-string">&#x27;pending&#x27;</span>;//默认的状态 pending<br>      this.value = undefined//成功的值默认undefined<br>      this.reason = undefined//失败的值默认undefined<br>      //状态只有在pending时候才能改变<br>      <span class="hljs-built_in">let</span> resolveFn = value =&gt;&#123;<br>        //判断只有等待时才能resolve成功<br>        <span class="hljs-keyword">if</span>(this.status == pending)&#123;<br>          this.status = <span class="hljs-string">&#x27;resolve&#x27;</span>;<br>          this.value = value;<br>        &#125;<br>      &#125;<br>      //判断只有等待时才能reject失败<br>      <span class="hljs-built_in">let</span> rejectFn = reason =&gt;&#123;<br>        <span class="hljs-keyword">if</span>(this.status == pending)&#123;<br>          this.status = <span class="hljs-string">&#x27;reject&#x27;</span>;<br>          this.reason = reason;<br>        &#125;<br>      &#125;    <br>      try&#123;<br>        //把resolve和reject两个函数传给执行器executer<br>        executer(resolve,reject);<br>      &#125;catch(e)&#123;<br>        reject(e);//失败的话进catch<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">then</span>(onFufilled,onReject)&#123;<br>      //如果状态成功调用onFufilled<br>      <span class="hljs-keyword">if</span>(this.status = <span class="hljs-string">&#x27;resolve&#x27;</span>)&#123;<br>        onFufilled(this.value);<br>      &#125;<br>      //如果状态失败调用onReject<br>      <span class="hljs-keyword">if</span>(this.status = <span class="hljs-string">&#x27;reject&#x27;</span>)&#123;<br>        onReject(this.reason);<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<h2 id="如何使用Set去重"><a href="#如何使用Set去重" class="headerlink" title="如何使用Set去重"></a>如何使用Set去重</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> arr = [12,43,23,43,68,12];<br><span class="hljs-built_in">let</span> item = [...new Set(arr)];<br>console.log(item);//[12, 43, 23, 68]<br></code></pre></td></tr></table></figure>
<h2 id="将下面for循环改成for-of形式"><a href="#将下面for循环改成for-of形式" class="headerlink" title="将下面for循环改成for of形式"></a>将下面for循环改成for of形式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> arr = [11,22,33,44,55];<br><span class="hljs-built_in">let</span> sum = 0;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">let</span> i=0;i&lt;arr.length;i++)&#123;<br>    sum += arr[i];<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">答案：<br><span class="hljs-built_in">let</span> arr = [11,22,33,44,55];<br><span class="hljs-built_in">let</span> sum = 0;<br><span class="hljs-keyword">for</span>(value of arr)&#123;<br>    sum += value;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="理解-async-await以及对Generator的优势"><a href="#理解-async-await以及对Generator的优势" class="headerlink" title="理解 async/await以及对Generator的优势"></a>理解 async/await以及对Generator的优势</h2><p>async await 是用来解决异步的，async函数是Generator函数的语法糖<br>使用关键字async来表示，在函数内部使用 await 来表示异步<br>async函数返回一个 Promise 对象，可以使用then方法添加回调函数<br>当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句<br>async较Generator的优势：<br>（1）内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样<br>（2）更好的语义。async 和 await 相较于 * 和 yield 更加语义化　　<br>（3）更广的适用性。yield命令后面只能是 Thunk 函数或 Promise对象，async函数的await后面可以是Promise也可以是原始类型的值<br>（4）返回值是 Promise。async 函数返回的是 Promise 对象，比Generator函数返回的Iterator对象方便，可以直接使用 then() 方法进行调用</p>
<h2 id="forEach、for-in、for-of三者区别"><a href="#forEach、for-in、for-of三者区别" class="headerlink" title="forEach、for in、for of三者区别"></a>forEach、for in、for of三者区别</h2><p>forEach更多的用来遍历数组<br>for in 一般常用来遍历对象或json<br>for of数组对象都可以遍历，遍历对象需要通过和Object.keys()<br>for in循环出的是key，for of循环出的是value</p>
<h2 id="说一下es6的导入导出模块"><a href="#说一下es6的导入导出模块" class="headerlink" title="说一下es6的导入导出模块"></a>说一下es6的导入导出模块</h2><p>导入通过import关键字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 只导入一个<br><br>import &#123;sum&#125; from <span class="hljs-string">&quot;./example.js&quot;</span><br><br>// 导入多个<br>import &#123;sum,multiply,time&#125; from <span class="hljs-string">&quot;./exportExample.js&quot;</span><br><br>// 导入一整个模块<br>import * as example from <span class="hljs-string">&quot;./exportExample.js&quot;</span><br></code></pre></td></tr></table></figure>
<p>导出通过export关键字<br>//可以将export放在任何变量,函数或类声明的前面</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> var firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br><span class="hljs-built_in">export</span> var lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<br><span class="hljs-built_in">export</span> var year = 1958;<br>//也可以使用大括号指定所要输出的一组变量<br>var firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br>var lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<br>var year = 1958;<br><span class="hljs-built_in">export</span> &#123;firstName, lastName, year&#125;;<br>//使用<span class="hljs-built_in">export</span> default时，对应的import语句不需要使用大括号<br><span class="hljs-built_in">let</span> bosh = <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">crs</span></span>()&#123;&#125;<br><span class="hljs-built_in">export</span> default bosh;<br>import crc from <span class="hljs-string">&#x27;crc&#x27;</span>;<br>//不使用<span class="hljs-built_in">export</span> default时，对应的import语句需要使用大括号<br><span class="hljs-built_in">let</span> bosh = <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">crs</span></span>()&#123;&#125;<br><span class="hljs-built_in">export</span> bosh;<br>import &#123;crc&#125; from <span class="hljs-string">&#x27;crc&#x27;</span>;<br></code></pre></td></tr></table></figure><div id="paginator"></div></div><div id="post-footer"><hr><a href="/2021/01/29/TypeScript-genericity/">TypeScript-genericity Next →</a><hr></div><div id="bottom-btn"><a id="to-index" href="#post-index" title="index">≡</a><a id="to-top" href="#post-title" title="to top">∧</a></div><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: ''
 , appKey: ''
 , placeholder: '此条评论委托企鹅物流发送'
})</script></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Complex</a></h1><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">3</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">3</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">3</span></div></section></div><div id="aside-block"><h1>INDEX</h1><div id="post-index"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ES5%E5%92%8CES6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">ES5和ES6的区别:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#var%E3%80%81let%E3%80%81const%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">var、let、const之间的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%BA%94%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">使用箭头函数应注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F%E5%B9%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">4.</span> <span class="toc-text">ES6的模板字符串有哪些新特性？并实现一个类模板字符串的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8B-Set%E3%80%81Map%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">介绍下 Set、Map的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ECMAScript6-%E6%80%8E%E4%B9%88%E5%86%99-class-%EF%BC%8C%E4%B8%BA%E4%BD%95%E4%BC%9A%E5%87%BA%E7%8E%B0-class%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">ECMAScript6 怎么写 class ，为何会出现 class？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%EF%BC%8C%E9%82%A3%E4%B9%88-then-%E6%96%B9%E6%B3%95%E5%91%A2%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">Promise构造函数是同步执行还是异步执行，那么 then 方法呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setTimeout%E3%80%81Promise%E3%80%81Async-Await-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.</span> <span class="toc-text">setTimeout、Promise、Async&#x2F;Await 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%BF%9B%E5%85%A5catch%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">promise有几种状态，什么时候会进入catch？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E7%9A%84%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">10.</span> <span class="toc-text">下面的输出结果是多少</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%E7%9A%84%E4%BA%A4%E6%8D%A2"><span class="toc-number">11.</span> <span class="toc-text">使用结构赋值，实现两个变量的值的交换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%94%AE%E5%90%8D%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%87%B3%E5%B0%91%E5%8C%85%E5%90%AB%E4%B8%80%E4%B8%AAsymbol%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89key"><span class="toc-number">12.</span> <span class="toc-text">设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2Set%E7%BB%93%E6%9E%84%EF%BC%8C%E6%89%93%E5%8D%B0%E5%87%BA%E7%9A%84size%E5%80%BC%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">13.</span> <span class="toc-text">下面Set结构，打印出的size值是多少</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-%E4%B8%ADreject-%E5%92%8C-catch-%E5%A4%84%E7%90%86%E4%B8%8A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">Promise 中reject 和 catch 处理上有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8class-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AApromise"><span class="toc-number">15.</span> <span class="toc-text">使用class 手写一个promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Set%E5%8E%BB%E9%87%8D"><span class="toc-number">16.</span> <span class="toc-text">如何使用Set去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E4%B8%8B%E9%9D%A2for%E5%BE%AA%E7%8E%AF%E6%94%B9%E6%88%90for-of%E5%BD%A2%E5%BC%8F"><span class="toc-number">17.</span> <span class="toc-text">将下面for循环改成for of形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-async-await%E4%BB%A5%E5%8F%8A%E5%AF%B9Generator%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">18.</span> <span class="toc-text">理解 async&#x2F;await以及对Generator的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#forEach%E3%80%81for-in%E3%80%81for-of%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">19.</span> <span class="toc-text">forEach、for in、for of三者区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8Bes6%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E6%A8%A1%E5%9D%97"><span class="toc-number">20.</span> <span class="toc-text">说一下es6的导入导出模块</span></a></li></ol></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">2021</span></nobr><wbr><wbr><nobr>published with&nbsp;<a href="javascript:;">Sibyl&nbsp;</a></nobr><wbr><nobr>by&nbsp;<a href="javascript:;">Complex</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>